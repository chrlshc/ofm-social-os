-- Media Pipeline: Assets and Variants with deduplication and S3 management
-- Supports upload, transcoding, and subtitle processing

BEGIN;

-- =============================================
-- Assets Table (Original uploaded content)
-- =============================================

CREATE TABLE IF NOT EXISTS assets (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  creator_id UUID NOT NULL,
  kind TEXT NOT NULL CHECK (kind IN ('video', 'image', 'audio')),
  original_filename TEXT,
  mime_type TEXT,
  s3_url TEXT NOT NULL,
  s3_bucket TEXT NOT NULL,
  s3_key TEXT NOT NULL,
  width INTEGER, -- For images/videos
  height INTEGER, -- For images/videos  
  duration DECIMAL(10,3), -- Duration in seconds for video/audio
  file_size_bytes BIGINT,
  content_hash TEXT NOT NULL UNIQUE, -- SHA-256 of binary content for deduplication
  upload_metadata JSONB DEFAULT '{}', -- Upload details (multipart info, etc.)
  processing_metadata JSONB DEFAULT '{}', -- FFprobe output, EXIF, etc.
  status TEXT NOT NULL DEFAULT 'uploaded' CHECK (status IN ('uploading', 'uploaded', 'processing', 'ready', 'failed')),
  processing_error TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for assets
CREATE INDEX IF NOT EXISTS idx_assets_creator_created ON assets(creator_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_assets_content_hash ON assets(content_hash);
CREATE INDEX IF NOT EXISTS idx_assets_status ON assets(status) WHERE status IN ('processing', 'failed');
CREATE INDEX IF NOT EXISTS idx_assets_s3_location ON assets(s3_bucket, s3_key);

-- =============================================
-- Variants Table (Processed versions)
-- =============================================

CREATE TABLE IF NOT EXISTS variants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  profile TEXT NOT NULL, -- '9x16', '1x1', '16x9', 'original', 'thumbnail', etc.
  s3_url TEXT NOT NULL,
  s3_bucket TEXT NOT NULL,
  s3_key TEXT NOT NULL,
  width INTEGER,
  height INTEGER,
  bitrate_kbps INTEGER, -- Video bitrate in kbps
  duration DECIMAL(10,3), -- Duration in seconds
  file_size_bytes BIGINT,
  variant_hash TEXT NOT NULL UNIQUE, -- SHA-256 of canonicalized FFmpeg command for deduplication
  ffmpeg_cmd TEXT, -- Full FFmpeg command used for reproducibility
  processing_time_ms INTEGER, -- Time taken to process this variant
  subtitle_tracks JSONB DEFAULT '[]', -- Array of subtitle track info
  metadata JSONB DEFAULT '{}', -- Codec info, quality metrics, etc.
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'ready', 'failed')),
  processing_error TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  
  -- Ensure unique variant per asset+profile combination
  UNIQUE(asset_id, profile)
);

-- Indexes for variants
CREATE INDEX IF NOT EXISTS idx_variants_asset ON variants(asset_id);
CREATE INDEX IF NOT EXISTS idx_variants_variant_hash ON variants(variant_hash);
CREATE INDEX IF NOT EXISTS idx_variants_profile ON variants(profile);
CREATE INDEX IF NOT EXISTS idx_variants_status ON variants(status) WHERE status IN ('processing', 'failed');
CREATE INDEX IF NOT EXISTS idx_variants_s3_location ON variants(s3_bucket, s3_key);

-- =============================================
-- Subtitle Tracks Table
-- =============================================

CREATE TABLE IF NOT EXISTS subtitle_tracks (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  variant_id UUID NOT NULL REFERENCES variants(id) ON DELETE CASCADE,
  language_code TEXT NOT NULL, -- ISO 639-1 (en, fr, es, etc.)
  language_name TEXT, -- Human readable language name
  format TEXT NOT NULL CHECK (format IN ('srt', 'vtt', 'mov_text')), -- Subtitle format
  s3_url TEXT, -- External subtitle file URL (for srt/vtt)
  embedded BOOLEAN NOT NULL DEFAULT false, -- Whether subtitle is embedded in video
  auto_generated BOOLEAN NOT NULL DEFAULT false, -- Generated by Whisper vs manual
  confidence_score DECIMAL(4,3), -- Whisper confidence score (0.0-1.0)
  word_count INTEGER,
  character_count INTEGER,
  transcription_metadata JSONB DEFAULT '{}', -- Whisper model info, timestamps, etc.
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  
  -- Ensure unique language per variant
  UNIQUE(variant_id, language_code, format)
);

-- Indexes for subtitle tracks
CREATE INDEX IF NOT EXISTS idx_subtitle_tracks_variant ON subtitle_tracks(variant_id);
CREATE INDEX IF NOT EXISTS idx_subtitle_tracks_language ON subtitle_tracks(language_code);
CREATE INDEX IF NOT EXISTS idx_subtitle_tracks_auto_generated ON subtitle_tracks(auto_generated);

-- =============================================
-- Upload Sessions (for multipart uploads)
-- =============================================

CREATE TABLE IF NOT EXISTS upload_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  creator_id UUID NOT NULL,
  upload_id TEXT NOT NULL, -- S3 multipart upload ID
  s3_bucket TEXT NOT NULL,
  s3_key TEXT NOT NULL,
  filename TEXT NOT NULL,
  mime_type TEXT,
  total_size_bytes BIGINT,
  uploaded_parts JSONB DEFAULT '[]', -- Array of completed part info
  status TEXT NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'completed', 'aborted', 'failed')),
  expires_at TIMESTAMPTZ NOT NULL DEFAULT (now() + INTERVAL '7 days'), -- S3 multipart expiration
  error_message TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  
  -- Ensure unique upload session per S3 upload
  UNIQUE(s3_bucket, s3_key, upload_id)
);

-- Indexes for upload sessions
CREATE INDEX IF NOT EXISTS idx_upload_sessions_creator ON upload_sessions(creator_id, created_at DESC);
CREATE INDEX IF NOT EXISTS idx_upload_sessions_status ON upload_sessions(status);
CREATE INDEX IF NOT EXISTS idx_upload_sessions_expires ON upload_sessions(expires_at) WHERE status = 'active';
CREATE INDEX IF NOT EXISTS idx_upload_sessions_s3_location ON upload_sessions(s3_bucket, s3_key);

-- =============================================
-- Processing Queue (for async media processing)
-- =============================================

CREATE TABLE IF NOT EXISTS media_processing_queue (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  asset_id UUID NOT NULL REFERENCES assets(id) ON DELETE CASCADE,
  operation_type TEXT NOT NULL CHECK (operation_type IN ('transcode', 'subtitle', 'thumbnail', 'analysis')),
  priority INTEGER NOT NULL DEFAULT 5, -- 1=highest, 10=lowest
  profiles TEXT[], -- Array of profiles to process (for transcode)
  parameters JSONB DEFAULT '{}', -- Operation-specific parameters
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'processing', 'completed', 'failed', 'cancelled')),
  worker_id TEXT, -- ID of worker processing this job
  started_at TIMESTAMPTZ,
  completed_at TIMESTAMPTZ,
  error_message TEXT,
  retry_count INTEGER NOT NULL DEFAULT 0,
  max_retries INTEGER NOT NULL DEFAULT 3,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT now()
);

-- Indexes for processing queue
CREATE INDEX IF NOT EXISTS idx_processing_queue_status ON media_processing_queue(status, priority, created_at) WHERE status IN ('pending', 'processing');
CREATE INDEX IF NOT EXISTS idx_processing_queue_asset ON media_processing_queue(asset_id);
CREATE INDEX IF NOT EXISTS idx_processing_queue_operation ON media_processing_queue(operation_type);
CREATE INDEX IF NOT EXISTS idx_processing_queue_worker ON media_processing_queue(worker_id) WHERE worker_id IS NOT NULL;

-- =============================================
-- Functions
-- =============================================

-- Function to update timestamps
CREATE OR REPLACE FUNCTION update_media_timestamp() RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at := now();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Add update triggers
DROP TRIGGER IF EXISTS assets_updated_at_trigger ON assets;
CREATE TRIGGER assets_updated_at_trigger
  BEFORE UPDATE ON assets
  FOR EACH ROW
  EXECUTE FUNCTION update_media_timestamp();

DROP TRIGGER IF EXISTS variants_updated_at_trigger ON variants;
CREATE TRIGGER variants_updated_at_trigger
  BEFORE UPDATE ON variants
  FOR EACH ROW
  EXECUTE FUNCTION update_media_timestamp();

DROP TRIGGER IF EXISTS upload_sessions_updated_at_trigger ON upload_sessions;
CREATE TRIGGER upload_sessions_updated_at_trigger
  BEFORE UPDATE ON upload_sessions
  FOR EACH ROW
  EXECUTE FUNCTION update_media_timestamp();

DROP TRIGGER IF EXISTS processing_queue_updated_at_trigger ON media_processing_queue;
CREATE TRIGGER processing_queue_updated_at_trigger
  BEFORE UPDATE ON media_processing_queue
  FOR EACH ROW
  EXECUTE FUNCTION update_media_timestamp();

-- Function to calculate variant hash
CREATE OR REPLACE FUNCTION calculate_variant_hash(
  asset_content_hash TEXT,
  profile TEXT,
  ffmpeg_cmd TEXT
) RETURNS TEXT AS $$
BEGIN
  -- Create deterministic hash from asset hash + profile + normalized command
  RETURN encode(digest(asset_content_hash || '|' || profile || '|' || ffmpeg_cmd, 'sha256'), 'hex');
END;
$$ LANGUAGE plpgsql IMMUTABLE;

-- Function to clean up expired upload sessions
CREATE OR REPLACE FUNCTION cleanup_expired_upload_sessions() RETURNS INTEGER AS $$
DECLARE
  cleaned_count INTEGER;
BEGIN
  UPDATE upload_sessions
  SET status = 'expired',
      updated_at = now()
  WHERE status = 'active'
    AND expires_at < now();
    
  GET DIAGNOSTICS cleaned_count = ROW_COUNT;
  RETURN cleaned_count;
END;
$$ LANGUAGE plpgsql;

-- =============================================
-- Views for common queries
-- =============================================

-- View for assets with their variant counts
CREATE OR REPLACE VIEW assets_with_variants AS
SELECT 
  a.*,
  COUNT(v.id) as variant_count,
  COUNT(v.id) FILTER (WHERE v.status = 'ready') as ready_variants,
  COUNT(v.id) FILTER (WHERE v.status = 'failed') as failed_variants,
  ARRAY_AGG(DISTINCT v.profile) FILTER (WHERE v.status = 'ready') as available_profiles
FROM assets a
LEFT JOIN variants v ON a.id = v.asset_id
GROUP BY a.id, a.creator_id, a.kind, a.original_filename, a.mime_type, 
         a.s3_url, a.s3_bucket, a.s3_key, a.width, a.height, a.duration,
         a.file_size_bytes, a.content_hash, a.upload_metadata, a.processing_metadata,
         a.status, a.processing_error, a.created_at, a.updated_at;

-- View for processing statistics
CREATE OR REPLACE VIEW media_processing_stats AS
SELECT 
  operation_type,
  status,
  COUNT(*) as count,
  AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) * 1000)::INTEGER as avg_processing_time_ms,
  MAX(EXTRACT(EPOCH FROM (completed_at - started_at)) * 1000)::INTEGER as max_processing_time_ms,
  AVG(retry_count) as avg_retries
FROM media_processing_queue
WHERE started_at IS NOT NULL
GROUP BY operation_type, status;

-- =============================================
-- Grants and Permissions
-- =============================================

GRANT SELECT, INSERT, UPDATE, DELETE ON assets TO authenticated;
GRANT USAGE ON SEQUENCE assets_id_seq TO authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON variants TO authenticated;
GRANT USAGE ON SEQUENCE variants_id_seq TO authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON subtitle_tracks TO authenticated;
GRANT USAGE ON SEQUENCE subtitle_tracks_id_seq TO authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON upload_sessions TO authenticated;
GRANT USAGE ON SEQUENCE upload_sessions_id_seq TO authenticated;

GRANT SELECT, INSERT, UPDATE, DELETE ON media_processing_queue TO authenticated;
GRANT USAGE ON SEQUENCE media_processing_queue_id_seq TO authenticated;

-- Views
GRANT SELECT ON assets_with_variants TO authenticated;
GRANT SELECT ON media_processing_stats TO authenticated;

-- Functions
GRANT EXECUTE ON FUNCTION calculate_variant_hash TO authenticated;
GRANT EXECUTE ON FUNCTION cleanup_expired_upload_sessions TO authenticated;

COMMIT;